"""Nix trace collector for capturing syscalls from Nix builds and runtime."""

import json
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import logging

from lib.strace.classes import Strace
from lib.strace.parser import parse_string
from lib.util.shell import run_command

logger = logging.getLogger(__name__)


class NixTraceCollector:
    """Collector for tracing Nix expressions and NixOS modules."""
    
    def __init__(self, store_path: str = "/nix/store"):
        self.store_path = Path(store_path)
        self.traces_db = {}
        
    def trace_nix_expression(self, 
                            expr: str, 
                            trace_build: bool = True,
                            trace_runtime: bool = True) -> Dict[str, Strace]:
        """
        Trace a Nix expression during build and/or runtime.
        
        Parameters
        ----------
        expr : str
            Nix expression to trace
        trace_build : bool
            Whether to trace the build phase
        trace_runtime : bool  
            Whether to trace the runtime/activation phase
            
        Returns
        -------
        Dict[str, Strace]
            Dictionary with 'build' and/or 'runtime' traces
        """
        traces = {}
        
        if trace_build:
            logger.info("Tracing Nix build phase")
            traces['build'] = self._trace_build(expr)
            
        if trace_runtime:
            logger.info("Tracing Nix runtime phase")
            traces['runtime'] = self._trace_runtime(expr)
            
        return traces
    
    def _trace_build(self, expr: str) -> Strace:
        """Trace syscalls during Nix build phase."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.nix') as f:
            f.write(expr)
            f.flush()
            
            # Run nix-build with strace
            cmd = f"strace -f -o /tmp/nix-build.strace nix-build {f.name} --no-out-link 2>/dev/null"
            
            try:
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                
                # Read and parse the strace output
                with open('/tmp/nix-build.strace', 'r') as strace_file:
                    strace_content = strace_file.read()
                    
                return parse_string(
                    strace_content,
                    system='nix',
                    executable='nix-build',
                    arguments={'expression': expr},
                    collector='NixTraceCollector',
                    metadata={'phase': 'build'}
                )
            except Exception as e:
                logger.error(f"Failed to trace build: {e}")
                raise
    
    def _trace_runtime(self, expr: str) -> Strace:
        """Trace syscalls during Nix runtime/activation phase."""
        # For NixOS modules, trace the activation script
        activation_script = self._generate_activation_script(expr)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.sh') as f:
            f.write(activation_script)
            f.flush()
            
            cmd = f"strace -f -o /tmp/nix-runtime.strace bash {f.name} 2>/dev/null"
            
            try:
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                
                with open('/tmp/nix-runtime.strace', 'r') as strace_file:
                    strace_content = strace_file.read()
                    
                return parse_string(
                    strace_content,
                    system='nix',
                    executable='activation',
                    arguments={'expression': expr},
                    collector='NixTraceCollector',
                    metadata={'phase': 'runtime'}
                )
            except Exception as e:
                logger.error(f"Failed to trace runtime: {e}")
                raise
    
    def _generate_activation_script(self, expr: str) -> str:
        """Generate activation script from Nix expression."""
        # Simplified - would need to handle NixOS module system properly
        return f"""#!/bin/bash
# Activation script for Nix expression
# This would normally be generated by NixOS
echo "Activating Nix configuration..."
"""
    
    def trace_nixos_module(self, module_path: str, config: Dict) -> Dict[str, Strace]:
        """
        Trace a NixOS module with specific configuration.
        
        Parameters
        ----------
        module_path : str
            NixOS module path (e.g., 'services.nginx')
        config : Dict
            Configuration for the module
            
        Returns
        -------
        Dict[str, Strace]
            Build and runtime traces
        """
        # Generate a minimal NixOS configuration using the module
        nix_expr = self._generate_nixos_test(module_path, config)
        return self.trace_nix_expression(nix_expr)
    
    def _generate_nixos_test(self, module_path: str, config: Dict) -> str:
        """Generate NixOS test configuration for a module."""
        config_str = self._dict_to_nix(config)
        
        return f"""
{{ config, pkgs, ... }}:
{{
  {module_path} = {config_str};
}}
"""
    
    def _dict_to_nix(self, d: Dict) -> str:
        """Convert Python dict to Nix attribute set syntax."""
        if isinstance(d, dict):
            attrs = []
            for k, v in d.items():
                attrs.append(f'{k} = {self._dict_to_nix(v)};')
            return '{\n  ' + '\n  '.join(attrs) + '\n}'
        elif isinstance(d, list):
            items = [self._dict_to_nix(i) for i in d]
            return '[ ' + ' '.join(items) + ' ]'
        elif isinstance(d, str):
            return f'"{d}"'
        elif isinstance(d, bool):
            return 'true' if d else 'false'
        elif isinstance(d, (int, float)):
            return str(d)
        else:
            return 'null'
    
    def compare_traces(self, trace1: Strace, trace2: Strace) -> float:
        """
        Compare two traces for similarity.
        
        Parameters
        ----------
        trace1 : Strace
            First trace
        trace2 : Strace
            Second trace
            
        Returns
        -------
        float
            Similarity score between 0 and 1
        """
        # Extract syscall patterns
        syscalls1 = self._extract_syscall_pattern(trace1)
        syscalls2 = self._extract_syscall_pattern(trace2)
        
        # Calculate Jaccard similarity
        intersection = syscalls1.intersection(syscalls2)
        union = syscalls1.union(syscalls2)
        
        if not union:
            return 0.0
            
        return len(intersection) / len(union)
    
    def _extract_syscall_pattern(self, trace: Strace) -> set:
        """Extract syscall pattern from trace."""
        pattern = set()
        
        for line in trace.trace_lines:
            if hasattr(line, 'syscall'):
                # Create pattern signature
                sig = f"{line.syscall.name}"
                if hasattr(line.syscall, 'args') and line.syscall.args:
                    # Include argument types in signature
                    arg_types = [type(arg).__name__ for arg in line.syscall.args[:2]]
                    sig += f"({','.join(arg_types)})"
                pattern.add(sig)
                
        return pattern